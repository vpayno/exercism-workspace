<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# resistorcolortrio

```go
import "resistorcolortrio"
```

Package resistorcolortrio helps users identify resistors using their color bands.

## Index

- [Variables](<#variables>)
- [func ColorCode(color string) int](<#func-colorcode>)
- [func Colors() []string](<#func-colors>)
- [func Label(colors []string) string](<#func-label>)
- [func Unit(value int) string](<#func-unit>)
- [func Value(colors []string) int](<#func-value>)
- [type Color](<#type-color>)
  - [func (c Color) Int() int](<#func-color-int>)
  - [func (c Color) String() string](<#func-color-string>)
- [type MetricPrefix](<#type-metricprefix>)
  - [func (m MetricPrefix) Int() int](<#func-metricprefix-int>)
  - [func (m MetricPrefix) Magnitude() int](<#func-metricprefix-magnitude>)
  - [func (m MetricPrefix) String() string](<#func-metricprefix-string>)


## Variables

ColorNames maps Color type to it's string representation.

```go
var ColorNames = map[Color]string{
    Undefined: "undefined",
    Black:     "black",
    Brown:     "brown",
    Red:       "red",
    Orange:    "orange",
    Yellow:    "yellow",
    Green:     "green",
    Blue:      "blue",
    Violet:    "violet",
    Grey:      "grey",
    White:     "white",
}
```

MetricPrefixNames maps MetrixPrefix to it's string representation.

```go
var MetricPrefixNames = map[MetricPrefix]string{
    NoPrefix: "",
    Kilo:     "kilo",
    Mega:     "mega",
    Giga:     "giga",
}
```

## func [ColorCode](<https://github.com/vpayno/exercism-workspace/blob/main/go/resistor-color-trio/resistor_color_trio.go#L152>)

```go
func ColorCode(color string) int
```

ColorCode returns the resistance value of the given color. I guess instead of having a map\[String\]int\{\} to do the lookups, we have to search a \[\]String\{\} array and find the element with that string and return the index. They really sucked the fun out of this function.

<details><summary>Example</summary>
<p>

```go
{
	var color Color

	for color = Undefined; color <= ColorMax; color++ {
		name := color.String()
		value := ColorCode(name)

		fmt.Printf("Resistor band color %s has a value of %d\n", name, value)
	}

}
```

#### Output

```
Resistor band color undefined has a value of -1
Resistor band color black has a value of 0
Resistor band color brown has a value of 1
Resistor band color red has a value of 2
Resistor band color orange has a value of 3
Resistor band color yellow has a value of 4
Resistor band color green has a value of 5
Resistor band color blue has a value of 6
Resistor band color violet has a value of 7
Resistor band color grey has a value of 8
Resistor band color white has a value of 9
```

</p>
</details>

## func [Colors](<https://github.com/vpayno/exercism-workspace/blob/main/go/resistor-color-trio/resistor_color_trio.go#L133>)

```go
func Colors() []string
```

Colors should return the list of all colors. They are limiting your implementation possibilities. Not sure why even bother having a function since the contents of it are very static. I don't wan't to use an array to store the color data, I'm going to use an Enum instead. Now to find a clever way of generating the data from an Enum type that isn't a type and it's just a bunch of constants.

<details><summary>Example</summary>
<p>

```go
{
	fmt.Printf("%v\n", Colors())

}
```

#### Output

```
[black brown red orange yellow green blue violet grey white]
```

</p>
</details>

## func [Label](<https://github.com/vpayno/exercism-workspace/blob/main/go/resistor-color-trio/resistor_color_trio.go#L209>)

```go
func Label(colors []string) string
```

Label describes the resistance label given the colors of a resistor. The label is a string with a resistance value with an unit appended \(e.g. "33 ohms", "470 kiloohms"\).

<details><summary>Example</summary>
<p>

```go
{

	bands := []string{
		"orange",
	}
	fmt.Printf("The resistor label for %v is %s\n", bands, Label(bands))

	bands = []string{
		"orange",
		"orange",
	}
	fmt.Printf("The resistor label for %v is %s\n", bands, Label(bands))

	bands = []string{
		"orange",
		"orange",
		"",
	}

	for _, color := range Colors() {
		bands[2] = color
		fmt.Printf("The resistor label for %v is %s\n", bands, Label(bands))
	}

}
```

#### Output

```
The resistor label for [orange] is -1 ohms
The resistor label for [orange orange] is -1 ohms
The resistor label for [orange orange black] is 33 ohms
The resistor label for [orange orange brown] is 330 ohms
The resistor label for [orange orange red] is 3 kiloohms
The resistor label for [orange orange orange] is 33 kiloohms
The resistor label for [orange orange yellow] is 330 kiloohms
The resistor label for [orange orange green] is 3 megaohms
The resistor label for [orange orange blue] is 33 megaohms
The resistor label for [orange orange violet] is 330 megaohms
The resistor label for [orange orange grey] is 3 gigaohms
The resistor label for [orange orange white] is 33 gigaohms
```

</p>
</details>

## func [Unit](<https://github.com/vpayno/exercism-workspace/blob/main/go/resistor-color-trio/resistor_color_trio.go#L186>)

```go
func Unit(value int) string
```

Unit returns the units for a given set of bands.

## func [Value](<https://github.com/vpayno/exercism-workspace/blob/main/go/resistor-color-trio/resistor_color_trio.go#L163>)

```go
func Value(colors []string) int
```

Value returns the resistance value of a resistor with a given colors.

<details><summary>Example</summary>
<p>

```go
{

	bands := []string{
		"brown",
	}
	fmt.Printf("The resistor value for %v is %d\n", bands, Value(bands))

	bands = []string{
		"brown",
		"green",
	}
	fmt.Printf("The resistor value for %v is %d\n", bands, Value(bands))

	bands = []string{
		"brown",
		"green",
		"violet",
	}
	fmt.Printf("The resistor value for %v is %d\n", bands, Value(bands))

}
```

#### Output

```
The resistor value for [brown] is -1
The resistor value for [brown green] is 15
The resistor value for [brown green violet] is 15
```

</p>
</details>

## type [Color](<https://github.com/vpayno/exercism-workspace/blob/main/go/resistor-color-trio/resistor_color_trio.go#L11>)

Color type represents the value of a resistor's band.

```go
type Color int
```

Color constants used as an Enum. Starts with \-1 for which is used as an undefined color.

```go
const (
    Undefined Color = iota - 1
    Black
    Brown
    Red
    Orange
    Yellow
    Green
    Blue
    Violet
    Grey
    White
)
```

To make Color lower and upper bound tests clearer, let's define constants. Black and White are at the lower and upper boundaries. All other colors should be between them.

```go
const (
    ColorMin Color = Black
    ColorMax       = White
)
```

### func \(Color\) [Int](<https://github.com/vpayno/exercism-workspace/blob/main/go/resistor-color-trio/resistor_color_trio.go#L70>)

```go
func (c Color) Int() int
```

Int returns the integer representation of a Color. Yes, we could just use int\(Color\); But, this is more fun.

<details><summary>Example</summary>
<p>

```go
{
	var color Color

	for color = Undefined; color <= ColorMax; color++ {
		name := toTitleCase(color.String())
		value := color.Int()

		fmt.Printf("%s is %d\n", name, value)
	}

}
```

#### Output

```
Undefined is -1
Black is 0
Brown is 1
Red is 2
Orange is 3
Yellow is 4
Green is 5
Blue is 6
Violet is 7
Grey is 8
White is 9
```

</p>
</details>

### func \(Color\) [String](<https://github.com/vpayno/exercism-workspace/blob/main/go/resistor-color-trio/resistor_color_trio.go#L60>)

```go
func (c Color) String() string
```

String implements the Stringer interface. Another way of getting the String equivalent of a Color. We're going to use both to help make this exercise interesting. You can also use a switch in here; But, since we have our min/max constants, this should be easier to maintain. This also allows us to provide a response for undefined colors without complicated error checking since this exercise lacks error returns on the functions being tested.

<details><summary>Example</summary>
<p>

```go
{
	var color Color

	for color = Undefined; color <= ColorMax; color++ {
		name := toTitleCase(color.String())
		value := color.String()

		fmt.Printf("%s is %s\n", name, value)
	}

}
```

#### Output

```
Undefined is undefined
Black is black
Brown is brown
Red is red
Orange is orange
Yellow is yellow
Green is green
Blue is blue
Violet is violet
Grey is grey
White is white
```

</p>
</details>

## type [MetricPrefix](<https://github.com/vpayno/exercism-workspace/blob/main/go/resistor-color-trio/resistor_color_trio.go#L79>)

MetricPrefix type represents the metric prefix of our resistor value.

```go
type MetricPrefix int
```

Enum of MetricPrefixes

```go
const (
    NoPrefix MetricPrefix = 3 * iota
    Kilo
    Mega
    Giga
)
```

To make MetricPrefix lower and upper bound tests clearer, let's define constants. Kilo and Giga are at the lower and upper boundaries. All other MetricPrefixes should be between them.

```go
const (
    MetricPrefixMin MetricPrefix = Kilo
    MetricPrefixMax              = Giga
)
```

### func \(MetricPrefix\) [Int](<https://github.com/vpayno/exercism-workspace/blob/main/go/resistor-color-trio/resistor_color_trio.go#L115>)

```go
func (m MetricPrefix) Int() int
```

Int returns the integer representation of a MetricPrefix.

<details><summary>Example</summary>
<p>

```go
{
	var metricPrefix MetricPrefix

	for metricPrefix = NoPrefix; metricPrefix <= MetricPrefixMax; metricPrefix += 3 {
		name := toTitleCase(metricPrefix.String())
		value := metricPrefix.Int()

		fmt.Printf("[%s] is [%d]\n", name, value)
	}

}
```

#### Output

```
[] is [0]
[Kilo] is [3]
[Mega] is [6]
[Giga] is [9]
```

</p>
</details>

### func \(MetricPrefix\) [Magnitude](<https://github.com/vpayno/exercism-workspace/blob/main/go/resistor-color-trio/resistor_color_trio.go#L123>)

```go
func (m MetricPrefix) Magnitude() int
```

<details><summary>Example</summary>
<p>

```go
{
	var metricPrefix MetricPrefix

	for metricPrefix = NoPrefix; metricPrefix <= MetricPrefixMax; metricPrefix += 3 {
		name := toTitleCase(metricPrefix.String())
		value := metricPrefix.Magnitude()

		fmt.Printf("[%s] is [%d]\n", name, value)
	}

}
```

#### Output

```
[] is [1]
[Kilo] is [1000]
[Mega] is [1000000]
[Giga] is [1000000000]
```

</p>
</details>

### func \(MetricPrefix\) [String](<https://github.com/vpayno/exercism-workspace/blob/main/go/resistor-color-trio/resistor_color_trio.go#L106>)

```go
func (m MetricPrefix) String() string
```

String implements the Stringer interface for MetricPrefix.

<details><summary>Example</summary>
<p>

```go
{
	var metricPrefix MetricPrefix

	for metricPrefix = NoPrefix; metricPrefix <= MetricPrefixMax; metricPrefix += 3 {
		name := toTitleCase(metricPrefix.String())
		value := metricPrefix.String()

		fmt.Printf("[%s] is [%s]\n", name, value)
	}

}
```

#### Output

```
[] is []
[Kilo] is [kilo]
[Mega] is [mega]
[Giga] is [giga]
```

</p>
</details>



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
