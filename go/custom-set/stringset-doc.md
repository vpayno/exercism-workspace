<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# stringset

```go
import "stringset"
```

## Index

- [func Disjoint(s1, s2 Set) bool](<#func-disjoint>)
- [func Equal(s1, s2 Set) bool](<#func-equal>)
- [func Subset(s1, s2 Set) bool](<#func-subset>)
- [type Set](<#type-set>)
  - [func Difference(s1, s2 Set) Set](<#func-difference>)
  - [func Intersection(s1, s2 Set) Set](<#func-intersection>)
  - [func New() Set](<#func-new>)
  - [func NewFromSlice(list []string) Set](<#func-newfromslice>)
  - [func Union(s1, s2 Set) Set](<#func-union>)
  - [func (s Set) Add(elem string)](<#func-set-add>)
  - [func (s Set) Has(elem string) bool](<#func-set-has>)
  - [func (s Set) IsEmpty() bool](<#func-set-isempty>)
  - [func (s Set) String() string](<#func-set-string>)


## func [Disjoint](<https://github.com/vpayno/exercism-workspace/blob/main/go/custom-set/custom_set.go#L109>)

```go
func Disjoint(s1, s2 Set) bool
```

Disjoint returns true when the intersection of two Sets is empty.

<details><summary>Example</summary>
<p>

```go
{
	slice1 := []string{"a", "b", "c"}
	slice2 := []string{"c", "d", "e"}
	set1 := NewFromSlice(slice1)
	set2 := NewFromSlice(slice2)

	fmt.Printf("Disjoint(%s, %s): %v\n", set1, set2, Disjoint(set1, set2))

	slice1 = []string{"a", "b", "c"}
	slice2 = []string{"d", "e", "f"}
	set1 = NewFromSlice(slice1)
	set2 = NewFromSlice(slice2)

	fmt.Printf("Disjoint(%s, %s): %v\n", set1, set2, Disjoint(set1, set2))

}
```

#### Output

```
Disjoint({"a", "b", "c"}, {"c", "d", "e"}): false
Disjoint({"a", "b", "c"}, {"d", "e", "f"}): true
```

</p>
</details>

## func [Equal](<https://github.com/vpayno/exercism-workspace/blob/main/go/custom-set/custom_set.go#L114>)

```go
func Equal(s1, s2 Set) bool
```

Equal returns true when two Sets are equal and false when they aren't.

<details><summary>Example</summary>
<p>

```go
{
	slice1 := []string{"a", "b", "c"}
	set1 := NewFromSlice(slice1)

	slice2 := []string{"a", "b", "c"}
	set2 := NewFromSlice(slice2)

	fmt.Printf("Equal(%s, %s): %v\n", set1, set2, Equal(set1, set2))

	slice2 = []string{"a", "x", "c"}
	set2 = NewFromSlice(slice2)

	fmt.Printf("Equal(%s, %s): %v\n", set1, set2, Equal(set1, set2))

}
```

#### Output

```
Equal({"a", "b", "c"}, {"a", "b", "c"}): true
Equal({"a", "b", "c"}, {"a", "c", "x"}): false
```

</p>
</details>

## func [Subset](<https://github.com/vpayno/exercism-workspace/blob/main/go/custom-set/custom_set.go#L83>)

```go
func Subset(s1, s2 Set) bool
```

Subset returns true if s2 is a subset of s1.

<details><summary>Example</summary>
<p>

```go
{
	slice1 := []string{"a", "b", "c"}
	slice2 := []string{"a", "c"}
	set1 := NewFromSlice(slice1)
	set2 := NewFromSlice(slice2)

	fmt.Printf("Subset(%s, %s): %v\n", set1, set2, Subset(set1, set2))

}
```

#### Output

```
Subset({"a", "b", "c"}, {"a", "c"}): false
```

</p>
</details>

## type [Set](<https://github.com/vpayno/exercism-workspace/blob/main/go/custom-set/custom_set.go#L9>)

Set type uses map keys since they have to be unique.

```go
type Set map[string]struct{}
```

### func [Difference](<https://github.com/vpayno/exercism-workspace/blob/main/go/custom-set/custom_set.go#L146>)

```go
func Difference(s1, s2 Set) Set
```

Difference returns the difference between two Sets.

<details><summary>Example</summary>
<p>

```go
{
	slice1 := []string{"a", "b", "c"}
	slice2 := []string{"c", "d", "e"}
	set1 := NewFromSlice(slice1)
	set2 := NewFromSlice(slice2)

	fmt.Printf("Difference(%s, %s): %s\n", set1, set2, Difference(set1, set2))

}
```

#### Output

```
Difference({"a", "b", "c"}, {"c", "d", "e"}): {"a", "b"}
```

</p>
</details>

### func [Intersection](<https://github.com/vpayno/exercism-workspace/blob/main/go/custom-set/custom_set.go#L129>)

```go
func Intersection(s1, s2 Set) Set
```

Intersection returns the common elements between two Sets.

<details><summary>Example</summary>
<p>

```go
{
	slice1 := []string{"a", "b", "c"}
	slice2 := []string{"c", "d", "e"}
	set1 := NewFromSlice(slice1)
	set2 := NewFromSlice(slice2)

	fmt.Printf("Intersection(%s, %s): %s\n", set1, set2, Intersection(set1, set2))

}
```

#### Output

```
Intersection({"a", "b", "c"}, {"c", "d", "e"}): {"c"}
```

</p>
</details>

### func [New](<https://github.com/vpayno/exercism-workspace/blob/main/go/custom-set/custom_set.go#L12>)

```go
func New() Set
```

New returns a new empty Set.

<details><summary>Example</summary>
<p>

```go
{
	set := New()

	fmt.Printf("set: %s\n", set.String())

}
```

#### Output

```
set: {}
```

</p>
</details>

### func [NewFromSlice](<https://github.com/vpayno/exercism-workspace/blob/main/go/custom-set/custom_set.go#L17>)

```go
func NewFromSlice(list []string) Set
```

NewFromSlice returns a new Set populated with the strings from the passed slice.

<details><summary>Example</summary>
<p>

```go
{
	slice := []string{"a", "b", "c"}
	set := NewFromSlice(slice)

	fmt.Printf("slice: %s\n", set.String())
	fmt.Printf("  set: %s\n", set.String())

}
```

#### Output

```
slice: {"a", "b", "c"}
  set: {"a", "b", "c"}
```

</p>
</details>

### func [Union](<https://github.com/vpayno/exercism-workspace/blob/main/go/custom-set/custom_set.go#L159>)

```go
func Union(s1, s2 Set) Set
```

Union returns a Set composed of both Sets.

<details><summary>Example</summary>
<p>

```go
{
	slice1 := []string{"a", "b", "c"}
	slice2 := []string{"c", "d", "e"}
	set1 := NewFromSlice(slice1)
	set2 := NewFromSlice(slice2)

	fmt.Printf("Union(%s, %s): %s\n", set1, set2, Union(set1, set2))

}
```

#### Output

```
Union({"a", "b", "c"}, {"c", "d", "e"}): {"a", "b", "c", "d", "e"}
```

</p>
</details>

### func \(Set\) [Add](<https://github.com/vpayno/exercism-workspace/blob/main/go/custom-set/custom_set.go#L77>)

```go
func (s Set) Add(elem string)
```

Add inserts an element into the Set.

<details><summary>Example</summary>
<p>

```go
{
	s1 := New()

	s1.Add("a")
	fmt.Printf("s1.Add(a): %s\n", s1.String())

	s1.Add("b")
	fmt.Printf("s1.Add(b): %s\n", s1.String())

	s1.Add("c")
	fmt.Printf("s1.Add(c): %s\n", s1.String())

}
```

#### Output

```
s1.Add(a): {"a"}
s1.Add(b): {"a", "b"}
s1.Add(c): {"a", "b", "c"}
```

</p>
</details>

### func \(Set\) [Has](<https://github.com/vpayno/exercism-workspace/blob/main/go/custom-set/custom_set.go#L70>)

```go
func (s Set) Has(elem string) bool
```

Has returns true if the string is found in the Set, false if it doesn't.

<details><summary>Example</summary>
<p>

```go
{
	slice := []string{"a", "b", "c"}
	s1 := NewFromSlice(slice)

	fmt.Printf("s1.Has(a): %v\n", s1.Has("a"))
	fmt.Printf("s1.Has(b): %v\n", s1.Has("b"))
	fmt.Printf("s1.Has(c): %v\n", s1.Has("c"))
	fmt.Printf("s1.Has(z): %v\n", s1.Has("z"))

}
```

#### Output

```
s1.Has(a): true
s1.Has(b): true
s1.Has(c): true
s1.Has(z): false
```

</p>
</details>

### func \(Set\) [IsEmpty](<https://github.com/vpayno/exercism-workspace/blob/main/go/custom-set/custom_set.go#L65>)

```go
func (s Set) IsEmpty() bool
```

IsEmpty returns true if the Set is empty, false if it isn't.

<details><summary>Example</summary>
<p>

```go
{
	s1 := New()

	slice := []string{"a", "b", "c"}
	s2 := NewFromSlice(slice)

	fmt.Printf("s1.IsEmpty(): %v\n", s1.IsEmpty())
	fmt.Printf("s2.IsEmpty(): %v\n", s2.IsEmpty())

}
```

#### Output

```
s1.IsEmpty(): true
s2.IsEmpty(): false
```

</p>
</details>

### func \(Set\) [String](<https://github.com/vpayno/exercism-workspace/blob/main/go/custom-set/custom_set.go#L28>)

```go
func (s Set) String() string
```

String returns the string version of the Set.



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
