    1|       |/// Exercise Url: <https://exercism.org/tracks/rust/exercises/series>
    2|       |
    3|       |/// Given a string of digits, output all the contiguous substrings of length n in that string in the order that they appear.
    4|       |///
    5|       |/// Not sure why we're not returning a Result here.
    6|       |///
    7|       |/// Example with a sequence of 5 digits and a span of 3:
    8|       |/// ```rust
    9|       |/// use series::*;
   10|       |///
   11|       |/// let want: Vec<String> = vec!["491".to_string(), "914".to_string(), "142".to_string()];
   12|       |/// let got: Vec<String> = series("49142", 3);
   13|       |///
   14|       |/// assert_eq!(got, want);
   15|       |/// ```
   16|       |///
   17|       |/// Example with a sequence of 5 digits and a span of 2:
   18|       |/// ```rust
   19|       |/// use series::*;
   20|       |///
   21|       |/// let want: Vec<String> = vec!["4914".to_string(), "9142".to_string()];
   22|       |/// let got: Vec<String> = series("49142", 4);
   23|       |///
   24|       |/// assert_eq!(got, want);
   25|       |/// ```
   26|     15|pub fn series(sequence: &str, span: usize) -> Vec<String> {
   27|     15|    match (sequence, span) {
   28|     15|        (_, span) if span == 0 => {
                          ^3
   29|       |            // this corner case, with_zero_length, doesn't make sense
   30|      3|            vec!["".to_string(); sequence.len() + 1]
   31|       |        }
   32|     12|        (sequence, _) if sequence.is_empty() => {
                       ^0
   33|       |            // why are we returning a vector with empty strings?
   34|      0|            vec!["".to_string(); sequence.len()]
   35|       |        }
   36|     12|        (sequence, span) if sequence.len() == span => {
                       ^3
   37|       |            // this corner case makes sense
   38|      3|            vec![sequence.to_string()]
   39|       |        }
   40|       |        // corner case ignored by tests
   41|      9|        (sequence, span) if sequence.len() < span => {
                       ^6
   42|      6|            vec![]
   43|       |        }
   44|      3|        _ => series_main(sequence, span),
   45|       |    }
   46|     15|}
  ------------------
  | series::series:
  |   26|     15|pub fn series(sequence: &str, span: usize) -> Vec<String> {
  |   27|     15|    match (sequence, span) {
  |   28|     15|        (_, span) if span == 0 => {
  |                          ^3
  |   29|       |            // this corner case, with_zero_length, doesn't make sense
  |   30|      3|            vec!["".to_string(); sequence.len() + 1]
  |   31|       |        }
  |   32|     12|        (sequence, _) if sequence.is_empty() => {
  |                       ^0
  |   33|       |            // why are we returning a vector with empty strings?
  |   34|      0|            vec!["".to_string(); sequence.len()]
  |   35|       |        }
  |   36|     12|        (sequence, span) if sequence.len() == span => {
  |                       ^3
  |   37|       |            // this corner case makes sense
  |   38|      3|            vec![sequence.to_string()]
  |   39|       |        }
  |   40|       |        // corner case ignored by tests
  |   41|      9|        (sequence, span) if sequence.len() < span => {
  |                       ^6
  |   42|      6|            vec![]
  |   43|       |        }
  |   44|      3|        _ => series_main(sequence, span),
  |   45|       |    }
  |   46|     15|}
  ------------------
  | Unexecuted instantiation: series::series
  ------------------
   47|       |
   48|      3|fn series_main(sequence: &str, span: usize) -> Vec<String> {
   49|      3|    // only one test to test the logic of the program?
   50|      3|    let mut groups: Vec<String> = vec![];
   51|      3|    let mut remaining: usize = sequence.len();
   52|       |
   53|     15|    for (index, _) in sequence.chars().enumerate() {
                                    ^3
   54|     15|        if remaining < span || index + span > sequence.len() {
                                             ^12
   55|      3|            break;
   56|     12|        }
   57|     12|        remaining -= 1;
   58|     12|
   59|     12|        let group: String = sequence[index..span + index].to_string();
   60|     12|
   61|     12|        groups.push(group);
   62|       |    }
   63|       |
   64|      3|    groups
   65|      3|}
  ------------------
  | series::series_main:
  |   48|      3|fn series_main(sequence: &str, span: usize) -> Vec<String> {
  |   49|      3|    // only one test to test the logic of the program?
  |   50|      3|    let mut groups: Vec<String> = vec![];
  |   51|      3|    let mut remaining: usize = sequence.len();
  |   52|       |
  |   53|     15|    for (index, _) in sequence.chars().enumerate() {
  |                                    ^3
  |   54|     15|        if remaining < span || index + span > sequence.len() {
  |                                             ^12
  |   55|      3|            break;
  |   56|     12|        }
  |   57|     12|        remaining -= 1;
  |   58|     12|
  |   59|     12|        let group: String = sequence[index..span + index].to_string();
  |   60|     12|
  |   61|     12|        groups.push(group);
  |   62|       |    }
  |   63|       |
  |   64|      3|    groups
  |   65|      3|}
  ------------------
  | Unexecuted instantiation: series::series_main
  ------------------